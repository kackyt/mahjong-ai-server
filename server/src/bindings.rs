/* automatically generated by rust-bindgen 0.69.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const MJ_INTERFACE_VERSION: u32 = 12;
pub const MJPI_INITIALIZE: u32 = 1;
pub const MJPI_SUTEHAI: u32 = 2;
pub const MJPI_ONACTION: u32 = 3;
pub const MJPI_STARTGAME: u32 = 4;
pub const MJPI_STARTKYOKU: u32 = 5;
pub const MJPI_ENDKYOKU: u32 = 6;
pub const MJPI_ENDGAME: u32 = 7;
pub const MJPI_DESTROY: u32 = 8;
pub const MJPI_YOURNAME: u32 = 9;
pub const MJPI_CREATEINSTANCE: u32 = 10;
pub const MJPI_BASHOGIME: u32 = 11;
pub const MJPI_ISEXCHANGEABLE: u32 = 12;
pub const MJPI_ONEXCHANGE: u32 = 13;
pub const MJMI_GETTEHAI: u32 = 1;
pub const MJMI_GETKAWA: u32 = 2;
pub const MJMI_GETDORA: u32 = 3;
pub const MJMI_GETSCORE: u32 = 4;
pub const MJMI_GETHONBA: u32 = 5;
pub const MJMI_GETREACHBOU: u32 = 6;
pub const MJMI_GETRULE: u32 = 7;
pub const MJMI_GETVERSION: u32 = 8;
pub const MJMI_GETMACHI: u32 = 9;
pub const MJMI_GETAGARITEN: u32 = 10;
pub const MJMI_GETHAIREMAIN: u32 = 11;
pub const MJMI_GETVISIBLEHAIS: u32 = 12;
pub const MJMI_FUKIDASHI: u32 = 13;
pub const MJMI_KKHAIABILITY: u32 = 14;
pub const MJMI_GETWAREME: u32 = 15;
pub const MJMI_SETSTRUCTTYPE: u32 = 16;
pub const MJMI_SETAUTOFUKIDASHI: u32 = 17;
pub const MJMI_LASTTSUMOGIRI: u32 = 18;
pub const MJMI_SSPUTOABILITY: u32 = 19;
pub const MJMI_GETYAKUHAN: u32 = 20;
pub const MJMI_GETKYOKU: u32 = 21;
pub const MJMI_GETKAWAEX: u32 = 22;
pub const MJMI_ANKANABILITY: u32 = 23;
pub const MJPIR_SUTEHAI: u32 = 256;
pub const MJPIR_REACH: u32 = 512;
pub const MJPIR_KAN: u32 = 1024;
pub const MJPIR_TSUMO: u32 = 2048;
pub const MJPIR_NAGASHI: u32 = 4096;
pub const MJPIR_PON: u32 = 8192;
pub const MJPIR_CHII1: u32 = 16384;
pub const MJPIR_CHII2: u32 = 32768;
pub const MJPIR_CHII3: u32 = 65536;
pub const MJPIR_MINKAN: u32 = 131072;
pub const MJPIR_ANKAN: u32 = 262144;
pub const MJPIR_RON: u32 = 524288;
pub const MJMIR_ERROR: u32 = 2147483648;
pub const MJR_NOTCARED: u32 = 4294967295;
pub const MJRL_KUITAN: u32 = 1;
pub const MJRL_KANSAKI: u32 = 2;
pub const MJRL_PAO: u32 = 3;
pub const MJRL_RON: u32 = 4;
pub const MJRL_MOCHITEN: u32 = 5;
pub const MJRL_BUTTOBI: u32 = 6;
pub const MJRL_WAREME: u32 = 7;
pub const MJRL_AKA5: u32 = 8;
pub const MJRL_SHANYU: u32 = 9;
pub const MJRL_SHANYU_SCORE: u32 = 10;
pub const MJRL_KUINAOSHI: u32 = 11;
pub const MJRL_AKA5S: u32 = 12;
pub const MJRL_URADORA: u32 = 13;
pub const MJRL_SCORE0REACH: u32 = 14;
pub const MJRL_RYANSHIBA: u32 = 15;
pub const MJRL_DORAPLUS: u32 = 16;
pub const MJRL_FURITENREACH: u32 = 17;
pub const MJRL_NANNYU: u32 = 18;
pub const MJRL_NANNYU_SCORE: u32 = 19;
pub const MJRL_KARATEN: u32 = 20;
pub const MJRL_PINZUMO: u32 = 21;
pub const MJRL_NOTENOYANAGARE: u32 = 22;
pub const MJRL_KANINREACH: u32 = 23;
pub const MJRL_TOPOYAAGARIEND: u32 = 24;
pub const MJRL_77MANGAN: u32 = 25;
pub const MJRL_DBLRONCHONBO: u32 = 26;
pub const MJEK_AGARI: u32 = 1;
pub const MJEK_RYUKYOKU: u32 = 2;
pub const MJEK_CHONBO: u32 = 3;
pub const MJST_INKYOKU: u32 = 1;
pub const MJST_BASHOGIME: u32 = 2;
pub const MJKS_REACH: u32 = 1;
pub const MJKS_NAKI: u32 = 2;
pub type UINT = ::std::os::raw::c_uint;
pub type USHORT = ::std::os::raw::c_ushort;
pub const MJI_YAKU_MJYK_REACH: MJI_YAKU = 0;
pub const MJI_YAKU_MJYK_IPPATSU: MJI_YAKU = 1;
pub const MJI_YAKU_MJYK_PINFU: MJI_YAKU = 2;
pub const MJI_YAKU_MJYK_IPEKO: MJI_YAKU = 3;
pub const MJI_YAKU_MJYK_TANYAO: MJI_YAKU = 4;
pub const MJI_YAKU_MJYK_FANPAI: MJI_YAKU = 5;
pub const MJI_YAKU_MJYK_TSUMO: MJI_YAKU = 6;
pub const MJI_YAKU_MJYK_HAITEI: MJI_YAKU = 7;
pub const MJI_YAKU_MJYK_HOTEI: MJI_YAKU = 8;
pub const MJI_YAKU_MJYK_RINSHAN: MJI_YAKU = 9;
pub const MJI_YAKU_MJYK_CHANKAN: MJI_YAKU = 10;
pub const MJI_YAKU_MJYK_DOUBLEREACH: MJI_YAKU = 11;
pub const MJI_YAKU_MJYK_CHITOI: MJI_YAKU = 12;
pub const MJI_YAKU_MJYK_CHANTA: MJI_YAKU = 13;
pub const MJI_YAKU_MJYK_ITTSU: MJI_YAKU = 14;
pub const MJI_YAKU_MJYK_SANSHOKUDOUJUN: MJI_YAKU = 15;
pub const MJI_YAKU_MJYK_SANSHOKUDOUKOU: MJI_YAKU = 16;
pub const MJI_YAKU_MJYK_TOITOI: MJI_YAKU = 17;
pub const MJI_YAKU_MJYK_SANANKOU: MJI_YAKU = 18;
pub const MJI_YAKU_MJYK_SANKANTSU: MJI_YAKU = 19;
pub const MJI_YAKU_MJYK_SHOUSANGEN: MJI_YAKU = 20;
pub const MJI_YAKU_MJYK_HONROUTOU: MJI_YAKU = 21;
pub const MJI_YAKU_MJYK_SANRENKOU: MJI_YAKU = 22;
pub const MJI_YAKU_MJYK_RYANPEKO: MJI_YAKU = 23;
pub const MJI_YAKU_MJYK_HONITSU: MJI_YAKU = 24;
pub const MJI_YAKU_MJYK_JUNCHAN: MJI_YAKU = 25;
pub const MJI_YAKU_MJYK_CHINITSU: MJI_YAKU = 26;
pub const MJI_YAKU_MJYK_RENHO: MJI_YAKU = 27;
pub const MJI_YAKU_MJYK_TENHO: MJI_YAKU = 28;
pub const MJI_YAKU_MJYK_CHIHO: MJI_YAKU = 29;
pub const MJI_YAKU_MJYK_DAISANGEN: MJI_YAKU = 30;
pub const MJI_YAKU_MJYK_TSUISO: MJI_YAKU = 31;
pub const MJI_YAKU_MJYK_SUSHIHO: MJI_YAKU = 32;
pub const MJI_YAKU_MJYK_CHINROUTOU: MJI_YAKU = 33;
pub const MJI_YAKU_MJYK_SUKANTSU: MJI_YAKU = 34;
pub const MJI_YAKU_MJYK_RYUISO: MJI_YAKU = 35;
pub const MJI_YAKU_MJYK_SUANKOU: MJI_YAKU = 36;
pub const MJI_YAKU_MJYK_KOKUSHI: MJI_YAKU = 37;
pub const MJI_YAKU_MJYK_CHUREN: MJI_YAKU = 38;
pub const MJI_YAKU_MJYK_SISANPUTO: MJI_YAKU = 39;
pub const MJI_YAKU_MJYK_DAISHARIN: MJI_YAKU = 40;
pub const MJI_YAKU_MJYK_NAGASHIMANGAN: MJI_YAKU = 41;
pub const MJI_YAKU_MJYK_DORA: MJI_YAKU = 42;
pub const MJI_YAKU_MJYK_SURENKOU: MJI_YAKU = 43;
pub const MJI_YAKU_MJYK_ISSHOKUSANJUN: MJI_YAKU = 44;
pub const MJI_YAKU_MJYK_ISSHOKUYONJUN: MJI_YAKU = 45;
pub const MJI_YAKU_MJI_YAKUS: MJI_YAKU = 46;
pub type MJI_YAKU = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MJITehai {
    pub tehai: [UINT; 14usize],
    pub tehai_max: UINT,
    pub minshun: [UINT; 4usize],
    pub minshun_max: UINT,
    pub minkou: [UINT; 4usize],
    pub minkou_max: UINT,
    pub minkan: [UINT; 4usize],
    pub minkan_max: UINT,
    pub ankan: [UINT; 4usize],
    pub ankan_max: UINT,
    pub reserved1: UINT,
    pub reserved2: UINT,
}
#[test]
fn bindgen_test_layout_MJITehai() {
    const UNINIT: ::std::mem::MaybeUninit<MJITehai> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MJITehai>(),
        148usize,
        concat!("Size of: ", stringify!(MJITehai))
    );
    assert_eq!(
        ::std::mem::align_of::<MJITehai>(),
        4usize,
        concat!("Alignment of ", stringify!(MJITehai))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tehai) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai),
            "::",
            stringify!(tehai)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tehai_max) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai),
            "::",
            stringify!(tehai_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minshun) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai),
            "::",
            stringify!(minshun)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minshun_max) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai),
            "::",
            stringify!(minshun_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minkou) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai),
            "::",
            stringify!(minkou)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minkou_max) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai),
            "::",
            stringify!(minkou_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minkan) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai),
            "::",
            stringify!(minkan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minkan_max) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai),
            "::",
            stringify!(minkan_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ankan) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai),
            "::",
            stringify!(ankan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ankan_max) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai),
            "::",
            stringify!(ankan_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai),
            "::",
            stringify!(reserved2)
        )
    );
}
pub type MJITehai0 = MJITehai;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct MJIHai {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_MJIHai() {
    assert_eq!(
        ::std::mem::size_of::<MJIHai>(),
        4usize,
        concat!("Size of: ", stringify!(MJIHai))
    );
    assert_eq!(
        ::std::mem::align_of::<MJIHai>(),
        4usize,
        concat!("Alignment of ", stringify!(MJIHai))
    );
}
impl MJIHai {
    #[inline]
    pub fn hai_no(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_hai_no(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn aka(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aka(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hai_no: ::std::os::raw::c_uint,
        aka: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let hai_no: u32 = unsafe { ::std::mem::transmute(hai_no) };
            hai_no as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let aka: u32 = unsafe { ::std::mem::transmute(aka) };
            aka as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MJITehai1 {
    pub tehai: [UINT; 14usize],
    pub tehai_max: UINT,
    pub minshun: [UINT; 4usize],
    pub minshun_max: UINT,
    pub minkou: [UINT; 4usize],
    pub minkou_max: UINT,
    pub minkan: [UINT; 4usize],
    pub minkan_max: UINT,
    pub ankan: [UINT; 4usize],
    pub ankan_max: UINT,
    pub minshun_hai: [[UINT; 4usize]; 3usize],
    pub minkou_hai: [[UINT; 4usize]; 3usize],
    pub minkan_hai: [[UINT; 4usize]; 4usize],
    pub ankan_hai: [[UINT; 4usize]; 4usize],
    pub reserved1: UINT,
    pub reserved2: UINT,
}
#[test]
fn bindgen_test_layout_MJITehai1() {
    const UNINIT: ::std::mem::MaybeUninit<MJITehai1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MJITehai1>(),
        372usize,
        concat!("Size of: ", stringify!(MJITehai1))
    );
    assert_eq!(
        ::std::mem::align_of::<MJITehai1>(),
        4usize,
        concat!("Alignment of ", stringify!(MJITehai1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tehai) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai1),
            "::",
            stringify!(tehai)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tehai_max) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai1),
            "::",
            stringify!(tehai_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minshun) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai1),
            "::",
            stringify!(minshun)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minshun_max) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai1),
            "::",
            stringify!(minshun_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minkou) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai1),
            "::",
            stringify!(minkou)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minkou_max) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai1),
            "::",
            stringify!(minkou_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minkan) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai1),
            "::",
            stringify!(minkan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minkan_max) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai1),
            "::",
            stringify!(minkan_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ankan) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai1),
            "::",
            stringify!(ankan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ankan_max) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai1),
            "::",
            stringify!(ankan_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minshun_hai) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai1),
            "::",
            stringify!(minshun_hai)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minkou_hai) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai1),
            "::",
            stringify!(minkou_hai)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minkan_hai) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai1),
            "::",
            stringify!(minkan_hai)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ankan_hai) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai1),
            "::",
            stringify!(ankan_hai)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai1),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(MJITehai1),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MJIKawahai {
    pub hai: USHORT,
    pub state: USHORT,
}
#[test]
fn bindgen_test_layout_MJIKawahai() {
    const UNINIT: ::std::mem::MaybeUninit<MJIKawahai> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MJIKawahai>(),
        4usize,
        concat!("Size of: ", stringify!(MJIKawahai))
    );
    assert_eq!(
        ::std::mem::align_of::<MJIKawahai>(),
        2usize,
        concat!("Alignment of ", stringify!(MJIKawahai))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hai) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MJIKawahai),
            "::",
            stringify!(hai)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MJIKawahai),
            "::",
            stringify!(state)
        )
    );
}
